#!/bin/bash
#
# Â©2020 Copyright 2020 Robert D. Chin
#
# Usage: bash file_recursive_rename.sh <TARGET DIRECTORY>
#        (not sh file_recursive_rename.sh)
#
# +----------------------------------------+
# |        Default Variable Values         |
# +----------------------------------------+
#
VERSION="2020-06-22 15:27"
THIS_FILE="file_recursive_rename.sh"
#
# +----------------------------------------+
# |            Brief Description           |
# +----------------------------------------+
#
#& Brief Description
#& 
#& 
#& This script will recursively rename files in the specified directory
#& and any sub-directories to enforce standard file naming conventions.
#& 
#& Files in hidden directories are excluded and are not renamed.
#& 
#& If you save articles from web pages as PDF files and use the title 
#& of the article as the PDF file name, you will probably end up with
#& various punctuation marks in your file name which are incompatible
#& or undesirable for any given Operating System (i.e. Unix, Linux,
#& Microsoft, Apple, Android).
#& 
#& Such file names derived from article titles often will contain
#& punctuation marks such as "?", "!", "/", "&", "%".
#& 
#& This script was written to enforce some of the file naming conventions
#& to ensure inter-Operating System compatibility.
#& 
#& It does not enforce all common file naming conventions, but only some
#& of the more common ones. See comments below for comprehensive list.
#& 
#& You may easily add more naming conventions in the "Start Main Program"
#& section of the script using the existing code as a template.
#& 
#&   Usage: bash file_recursive_rename.sh <TARGET DIRECTORY>
#&          bash file_recursive_rename.sh /home/user/Documents
#
# +----------------------------------------+
# |             Help and Usage             |
# +----------------------------------------+
#
#?    Usage: bash file_recursive_rename.sh [Target_Directory]
#?           bash file_recursive_rename.sh [OPTION]
#? Examples:
#?
#?bash file_recursive_rename.sh [Target_Directory] 
#?                                         # Rename files in directory.
#?
#?bash file_recursive_rename.sh --help     # Displays this help message.
#?                              -?
#?
#?bash file_recursive_rename.sh --about    # Displays script version.
#?                              --version
#?                              --ver
#?                              -v
#?
#?bash file_recursive_rename.sh --history  # Displays script code history.
#?                              --hist
#
# +----------------------------------------+
# |           Code Change History          |
# +----------------------------------------+
#
## Code Change History
##
## (After each edit made, please update Code History and VERSION.)
##
## CODE HISTORY
##
## 2020-04-28 *Main Program updated to latest standards.
##
## 2020-04-02 *Main Program minor enhancements.
##
## 2019-12-31 *Main Program excluded hidden directories from file
##             renaming process.
##
## 2019-05-10 *Main Program included time-stamp in log file names.
##            *Main Program added deletion of temporary files and 
##             unneeded log files.
##
## 2019-05-08 *Initial release.
#
# +----------------------------------------+
# |         Function f_script_path         |
# +----------------------------------------+
#
#     Rev: 2020-04-20
#  Inputs: $BASH_SOURCE (System variable).
#    Uses: None.
# Outputs: SCRIPT_PATH, THIS_DIR.
#
f_script_path () {
      #
      # BASH_SOURCE[0] gives the filename of the script.
      # dirname "{$BASH_SOURCE[0]}" gives the directory of the script
      # Execute commands: cd <script directory> and then pwd
      # to get the directory of the script.
      # NOTE: This code does not work with symlinks in directory path.
      #
      # !!!Non-BASH environments will give error message about line below!!!
      SCRIPT_PATH=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
      THIS_DIR=$SCRIPT_PATH  # Set $THIS_DIR to location of this script.
      #
} # End of function f_script_path.
#
# +----------------------------------------+
# |         Function f_arguments           |
# +----------------------------------------+
#
#     Rev: 2020-04-28 (Customized)
#  Inputs: $1=Argument
#             [--help] [ -h ] [ -? ]
#             [--about]
#             [--version] [ -ver ] [ -v ] [--about ]
#             [--history] [--hist ]
#             [] [ text ] [ dialog ] [ whiptail ]
#    Uses: None.
# Outputs: GUI, ERROR.
#
f_arguments () {
      #
      # If there is more than one argument, display help USAGE message, because only one argument is allowed.
      if [ $# -ge 2 ] ; then
         f_help_message text
         exit 0  # This cleanly closes the process generated by #!bin/bash. 
                 # Otherwise every time this script is run, another instance of
                 # process /bin/bash is created using up resources.
      fi
      #
      case $1 in
           --help | "-?")
              # If the one argument is "--help" display help USAGE message.
              f_help_message text
              exit 0  # This cleanly closes the process generated by #!bin/bash. 
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           --about | --version | --ver | -v)
              f_about text
              exit 0  # This cleanly closes the process generated by #!bin/bash. 
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           --history | --hist)
              f_code_history text
              exit 0  # This cleanly closes the process generated by #!bin/bash. 
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           -*)
              # If the one argument is "-<unrecognized>" display help USAGE message.
              f_help_message text
              exit 0  # This cleanly closes the process generated by #!bin/bash. 
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
      esac
      #
}  # End of function f_arguments.
#
# +----------------------------------------+
# |            Function f_abort            |
# +----------------------------------------+
#
#  Inputs: LOG_FILE.
#    Uses: RUNAPP, TEMP_FILE, FILEVR, X.
# Outputs: None.
#
f_abort() {
      echo $(tput setaf 1) # Set font to color red.
      echo "***************" |  tee -a $LOG_FILE
      echo "*** ABORTED ***" |  tee -a $LOG_FILE
      echo "***************" |  tee -a $LOG_FILE
      echo |  tee -a $LOG_FILE*
      echo "An error occurred. Exiting..." |  tee -a $LOG_FILE
      echo -n $(tput sgr0) # Set font to normal color.
      exit 1
} # End of function f_abort
#
# +------------------------------------+
# |          Function f_about          |
# +------------------------------------+
#
#     Rev: 2020-05-28
#  Inputs: $1=GUI - "text", "dialog" or "whiptail" the preferred user-interface.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: X.
# Outputs: None.
#
f_about () {
      #
      # Specify $THIS_FILE name of any file containing the text to be displayed.
      THIS_FILE="file_recursive_rename.sh"
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      # Set $VERSION according as it is set in the beginning of $THIS_FILE.
      X=$(grep --max-count=1 "VERSION" $THIS_FILE)
      # X="VERSION=YYYY-MM-DD HH:MM"
      # Use command "eval" to set $VERSION.
      eval $X
      #
      echo "Script: $THIS_FILE. Version: $VERSION" >$TEMP_FILE
      echo >>$TEMP_FILE
      #
      # Display text (all lines beginning ("^") with "#& " but do not print "#& ").
      # sed substitutes null for "#& " at the beginning of each line
      # so it is not printed.
      DELIM="^#&"
      sed -n "s/$DELIM//"p $THIS_DIR/$THIS_FILE >> $TEMP_FILE
      #
      f_message $1 "OK" "About (use arrow keys to scroll up/down/side-ways)" $TEMP_FILE
      #
} # End of f_about.
#
# +------------------------------------+
# |      Function f_code_history       |
# +------------------------------------+
#
#     Rev: 2020-05-24
#  Inputs: $1=GUI - "text", "dialog" or "whiptail" the preferred user-interface.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: X.
# Outputs: None.
#
f_code_history () {
      #
      # Specify $THIS_FILE name of any file containing the text to be displayed.
      THIS_FILE="file_recursive_rename.sh"
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      # Set $VERSION according as it is set in the beginning of $THIS_FILE.
      X=$(grep --max-count=1 "VERSION" $THIS_FILE)
      # X="VERSION=YYYY-MM-DD HH:MM"
      # Use command "eval" to set $VERSION.
      eval $X
      #
      echo "Script: $THIS_FILE. Version: $VERSION" >$TEMP_FILE
      echo >>$TEMP_FILE
      #
      # Display text (all lines beginning ("^") with "##" but do not print "##").
      # sed substitutes null for "##" at the beginning of each line
      # so it is not printed.
      DELIM="^##"
      sed -n "s/$DELIM//"p $THIS_DIR/$THIS_FILE >> $TEMP_FILE
      #
      f_message $1 "OK" "Code History (use arrow keys to scroll up/down/side-ways)" $TEMP_FILE
      #
} # End of function f_code_history.
#
# +------------------------------------+
# |      Function f_help_message       |
# +------------------------------------+
#
#     Rev: 2020-04-20
#  Inputs: $1=GUI - "text", "dialog" or "whiptail" the preferred user-interface.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: X.
# Outputs: None.
#
f_help_message () {
      #
      # Specify $THIS_FILE name of any file containing the text to be displayed.
      THIS_FILE="file_recursive_rename.sh"
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      # Set $VERSION according as it is set in the beginning of $THIS_FILE.
      X=$(grep --max-count=1 "VERSION" $THIS_FILE)
      # X="VERSION=YYYY-MM-DD HH:MM"
      # Use command "eval" to set $VERSION.
      eval $X
      #
      echo "Script: $THIS_FILE. Version: $VERSION" >$TEMP_FILE
      echo >>$TEMP_FILE
      #
      # Display text (all lines beginning with "#?" but do not print "#?").
      # sed substitutes null for "#?" at the beginning of each line
      # so it is not printed.
      sed -n 's/^#?//'p $THIS_DIR/$THIS_FILE >> $TEMP_FILE
      #
      f_msg_txt_file_ok text "OK" "Usage (use arrow keys to scroll up/down/side-ways)" $TEMP_FILE
      #
} # End of f_help_message.
#
# +------------------------------+
# |       Function f_message     |
# +------------------------------+
#
#     Rev: 2020-06-03
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file. 
#          $5 - (Optional for functions f_msg_ui/txt_str_nok) Pause for $5 seconds to allow text to be read.
#    Uses: None.
# Outputs: ERROR.
#   Usage: 1. f_message $GUI "OK" "Test of String in quotes" "This is a test of \Z6cyan software BASH script.\Zn\nI hope it works!"
#
#          2. In this example, the quotation marks around the "$STRING" variable name are required.
#             STRING=$(echo "\"Roses are \Z1\ZbRED\Zn, Violets are \Z4BLUE\Zn, what say you?\"")
#             f_message $GUI "OK" "Test of String in a variable" "$STRING" <---!!Note required quotation marks around variable name!!
#
#          3. echo "Line 1 of text file" >$TEMP_FILE
#             echo "Line 2 of text file" >>$TEMP_FILE
#             echo "Line 3 of text file" >>$TEMP_FILE
#             f_message $GUI "OK" "Test of Text file" $TEMP_FILE
#
# This will display a title and some text using dialog/whiptail/text.
# It will automatically calculate the optimum size of the displayed
# Dialog or Whiptail box depending on screen resolution, number of lines
# of text, and length of sentences to be displayed. 
#
# It is a lengthy function, but using it allows for an easy way to display 
# some text (in a string or text file) using either Dialog, Whiptail or text.
#
# You do not have to worry about the differences in syntax between Dialog
# and Whiptail or about calculating the box size for each text message.
#
f_message () {
      #
      case $1 in
           "dialog" | "whiptail")
              # Dialog boxes "--msgbox" "--infobox" can use option --colors with "\Z" commands for font color bold/normal.
              # Dialog box "--textbox" and Whiptail cannot use option --colors with "\Z" commands for font color bold/normal.
              #
              # If text strings have Dialog "\Z" commands for font color bold/normal, 
              # they must be used AFTER \n (line break) commands.
              # Example: "This is a test.\n\Z1\ZbThis is in bold-red letters.\n\ZnThis is in normal font."
              #
              # Get the screen resolution or X-window size.
              # Get rows (height).
              YSCREEN=$(stty size | awk '{ print $1 }')
              # Get columns (width).
              XSCREEN=$(stty size | awk '{ print $2 }')
              #
              # Is $4 a text string or a text file?
              if [ -r "$4" ] ; then
                 #
                 # If $4 is a text file, then calculate number of lines and length
                 # of sentences to calculate height and width of Dialog box.
                 # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
                 f_msg_ui_file_box_size $1 $2 "$3" "$4"
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text file with an [OK] button.
                    f_msg_ui_file_ok $1 $2 "$3" "$4" $YBOX $XBOX
                 else
                    # Display contents of text file with a pause for n seconds.
                    f_msg_ui_file_nok $1 $2 "$3" "$4" $YBOX $XBOX
                 fi
                 #
              else
                 # If $4 is a text string, then does it contain just one
                 # sentence or multiple sentences delimited by "\n"?
                 # Calculate the length of the longest of sentence.
                 # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
                 f_msg_ui_str_box_size $1 $2 "$3" "$4"
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text string with an [OK] button.
                    f_msg_ui_str_ok $1 $2 "$3" "$4" $YBOX $XBOX
                 else
                    # Display contents of text string with a pause for n seconds.
                    f_msg_ui_str_nok $1 $2 "$3" "$4" $YBOX $XBOX "$5"
                 fi
              fi
              ;;
           *)
              #
              # Text only.
              # Is $4 a text string or a text file?
              #
              # Change font color according to Dialog "\Z" commands.
              # Replace font color "\Z" commands with "tput" commands.
              # Output result to string $ZNO.
              f_msg_color "$4"
              #
              if [ -r "$4" ] ; then
                 # If $4 is a text file.
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text file using command "less" <q> to quit.
                    f_msg_txt_file_ok $1 $2 "$3" "$4"
                 else
                    f_msg_txt_file_nok $1 $2 "$3" "$4" "$5"
                    # Display contents of text file using command "cat" then pause for n seconds.
                 fi
                 #
              else
                 # If $4 is a text string.
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text string using command "echo -e" then
                    # use f_press_enter_key_to_continue.
                    f_msg_txt_str_ok $1 $2 "$3" "$ZNO"
                 else
                    # Display contents of text string using command "echo -e" then pause for n seconds.
                    f_msg_txt_str_nok $1 $2 "$3" "$ZNO" "$5"
                 fi
              fi
              #
              # Restore default font color.
              echo -n $(tput sgr0)
              #
           ;;
      esac
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
} # End of function f_message.
#
# +------------------------------+
# |  Function f_msg_txt_file_ok  |
# +------------------------------+
#
#     Rev: 2020-04-22
#  Inputs: $1 - "text", "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file. 
#    Uses: None.
# Outputs: ERROR. 
#
f_msg_txt_file_ok () {
      #
      # If $2 is "OK" then use command "less".
      #
      clear  # Blank the screen.
      #
      # Display text file contents.
      less -P '%P\% (Spacebar, PgUp/PgDn, Up/Dn arrows, press q to quit)' $4
      #
      clear  # Blank the screen.
      #
} # End of function f_msg_txt_file_ok
#
# +----------------------------------------+
# |            Start Main Program          |
# +----------------------------------------+
#
#   Usage: bash file_recursive_rename.sh <TARGET DIRECTORY>
#          bash file_recursive_rename.sh /home/user/Documents
#
#  Inputs: $1=TARGET_DIR
#    Uses: XSTR.
# Outputs: None.
#
clear  # Blank the screen.
#
# Set THIS_DIR, SCRIPT_PATH to directory path of script.
f_script_path
#
# Test for Optional Arguments.
f_arguments $1  # Also sets variable GUI.
#
TSTAMP=$(date --date=now +"%Y-%m-%d_%H%M")
LOG_FILE="file_recursive_rename_$TSTAMP.log"
TEMP_FILE="file_recursive_rename_$TSTAMP.tmp"
REQUIRED_FILE="file_rename.sh"
#
# Put the date stamp in the header of the log file.
echo
echo -n "Script $THIS_FILE" | tee $LOG_FILE
echo -n "Start time: " | tee $LOG_FILE
date | tee -a $LOG_FILE
#
#
if [ -z $1 ] ; then
   echo -n $(tput setaf 1) # Set font to color red.
   echo  | tee -a $LOG_FILE
   echo  "!!!WARNING!!! No target directory was specified." | tee -a $LOG_FILE
   echo  "Usage: bash file_recursive_rename.sh <Target Directory name>" | tee -a $LOG_FILE
   f_abort
fi
#
if [ ! -d $1 ] ; then
   echo -n $(tput setaf 1) # Set font to color red.
   echo | tee -a $LOG_FILE
   echo  "!!!WARNING!!! Cannot continue, \"$1\" directory either does not exist" | tee -a $LOG_FILE
   echo  "or you do not have WRITE permission to the directory: \"$1\"." | tee -a $LOG_FILE
   f_abort
fi
#
if [ ! -r $REQUIRED_FILE ] ; then
   echo -n $(tput setaf 1) # Set font to color red.
   echo | tee -a $LOG_FILE
   echo "!!!WARNING!!! Cannot continue, script \"$REQUIRED_FILE\" either does not exist" | tee -a $LOG_FILE
   echo "or you do not have READ permission to the script: \"$REQUIRED_FILE\"."   echo | tee -a $LOG_FILE
   f_abort
fi
#
# Find all sub-directories under specified directory.
find $1 -type d >$TEMP_FILE
#
# Do not rename files in hidden directories.
# Filter out any hidden directory names from the list of directories
# to be processed.
TEMP_FILE2="file_recursive_rename2_$TSTAMP.tmp"
grep --invert-match -F "/." $TEMP_FILE > $TEMP_FILE2
mv $TEMP_FILE2 $TEMP_FILE
#
echo >> $LOG_FILE
echo "List of Directories for file renaming." >> $LOG_FILE
echo "--------------------------------------" >> $LOG_FILE
cat $TEMP_FILE >>$LOG_FILE
echo "--------------------------------------" >> $LOG_FILE
echo "End of List of Directories">> $LOG_FILE
echo >> $LOG_FILE
#
while read XSTR
do
      echo "Rename files in $XSTR"
      echo
      bash file_rename.sh $XSTR
      echo
      echo
      echo "--------------------------------------------"
      echo
      echo
done < $TEMP_FILE
#
# Find the name of any files that were renamed and append that excerpt to LOG_FILE.
grep renamed file_rename*.log >> $LOG_FILE
#
# List log files for each sub-directory in a temporary file.
ls -l file_rename*.log >$TEMP_FILE
#
# Display list of log files for each sub-directory.
# Detect installed file viewer.
RUNAPP=0
for FILEVR in most more less
    do
    if [ $RUNAPP -eq 0 ] ; then
       type $FILEVR >/dev/null 2>&1  # Test if $FILEVR application is installed.
       ERROR=$?
       if [ $ERROR -eq 0 ] ; then
          $FILEVR $TEMP_FILE
          RUNAPP=1
       fi
    fi
    done
unset RUNAPP FILEVR
# Record finish time in log file.
echo | tee -a $LOG_FILE
echo -n "Script $THIS_FILE Finish time: " | tee -a $LOG_FILE
date | tee -a $LOG_FILE
#
# Ask user to delete old log files.
echo
echo "The detailed log files are not necessary, a comprehensive list"
echo "of renaming actions are recorded in log \"$LOG_FILE\"."
echo
echo -n "Delete detailed log files of actions in each directory (Y/n)? " ; read X
case $X in
     [Nn] | [Nn][Oo])
     echo
     echo "Detailed log files were not deleted."
     echo
     ;;
     *)
     # Delete log files.
     rm file_rename*.log
     echo
     echo "Detailed log files were deleted."
     echo
     ;;
esac
#
# Remove Temporary file.
if [ -e $TEMP_FILE ] ; then
   rm $TEMP_FILE
fi
#
# All Dun Dun noodles.
